# https://cryptobook.nakov.com/cryptographic-hash-functions/secure-hash-algorithms#sha-3-sha3-256-sha3-512-keccak-256
# SHA-3 "Keccak" hashes family was winner in SHA-3 NIST competition 2013.
from hashlib import sha256, sha3_256
from base64 import b32decode
from binascii import crc32

ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP = 64
ADDRMAN_NEW_BUCKET_COUNT = 1024

def b32_padding(data):
    padding = ""
    match len(data) % 8:
        case 2:
            padding = "======"
        case 4:
            padding = "===="
        case 5:
            padding = "==="
        case 7:
            padding = "=="
    return padding

print("======")
print("getgroup")
print("======\n")
"""ipv4 address is made of 4 chunks (8 bit each)"""
def get_group_ipv4(ip):
    ip_as_bytes = bytes(map(int, ip.split('.')))
    return bytes([1]) + ip_as_bytes[:2]
print("ipv4", get_group_ipv4("1.2.3.4"))

"""ipv6 address is made of 8 chunks (16 bit each)"""
def get_group_ipv6(ip):
    ip_as_bytes = bytes.fromhex(ip.replace(':',''))
    return bytes([2]) + ip_as_bytes[:4]
print("ipv6", get_group_ipv6("2001:2001:9999:9999:9999:9999:9999:9999"))

"""
tor v3 address is 56 characters long. A tor v3 address will always end in a d due to the way v3 onion service names are encoded.

onion_address = base32(PUBKEY | CHECKSUM | VERSION) + ".onion"
CHECKSUM = H(".onion checksum" | PUBKEY | VERSION)[:2]
where:
       - PUBKEY is the 32 bytes ed25519 master pubkey of the hidden service.
       - VERSION is a one byte version field (default value '\x03')
       - ".onion checksum" is a constant string
       - CHECKSUM is truncated to two bytes before inserting it in onion_address
"""
def get_group_tor(ip):
    ip = ip.replace('.onion','')
    raw_bytes = b32decode(ip, casefold=True)
    pubkey, checksum, version = raw_bytes[:32], raw_bytes[32:34], raw_bytes[-1:]
    assert version == b'\x03'
    assert checksum == sha3_256(b".onion checksum" + pubkey + version).digest()[:2]
    return bytes([3]) + bytes([pubkey[0]|0xf]) # only first 4 bits of 1st byte taken
print("tor", get_group_tor("pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion")) #b'\x03\x7f'

def get_group_i2p(ip):
    ip = ip.replace('.b32.i2p','')
    # requires base32 padding, we have 52 characters right now + we need 56 characters apparently (see below)
    data = b32decode(ip+b32_padding(ip), casefold=True)
    # TODO: difference between encryptedleaseset and b32encrypted + checksum calculation
    # https://geti2p.net/spec/encryptedleaseset => total requirements are 32 + 3 = 35 bytes, requiring 56 characters in base 32
    # https://geti2p.net/spec/b32encrypted
    # data = ((1 byte flags || 1 byte unblinded sigtype || 1 byte blinded sigtype) XOR checksum) || 32 byte pubkey
    # address = Base32Encode(data) || ".b32.i2p"
    pubkey = data[-32:]
    return bytes([4]) + bytes([pubkey[0]|0xf])
print("i2p", get_group_i2p("ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p")) #b'\x04\xaf'

"""
CJDNS IPv6 address is generated by using the first 16 bytes of a double SHA-512 of your public key.
All cjdns IPv6 addresses must begin with "fc" or else they are invalid"""
def get_group_cjdns(ip):
    # todo: not recognising cjdns address "all other unroutable addresses belong to the same group"
    pass
print("cjdns", get_group_cjdns("fc00:1:2:3:4:5:6:7"))

print("======")
print("bucketing algo")
print("======\n")
def double_hash(bytes):
    return sha256(sha256(bytes).digest()).digest()

def get_new_bucket(key, addr, src):
    addr_group = get_group_ipv4(addr)
    src_group = get_group_ipv4(src)
    hash1 =  int.from_bytes(double_hash(key + bytes([len(addr_group)]) + addr_group
                                            + bytes([len(src_group)]) + src_group)[:8], 'little')
    hash1 = hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP #64
    hash2 = int.from_bytes(double_hash(key + bytes([len(src_group)]) + src_group
                                           + hash1.to_bytes(8, 'little'))[:8], 'little')
    return hash2 % ADDRMAN_NEW_BUCKET_COUNT #1024

key = bytes.fromhex("41f758f2e5cc078d3795b4fc0cb60c2d735fa92cc020572bdc982dd2d564d11b")
addr = "250.1.2.1"
src = "250.1.2.1"
bucket = get_new_bucket(key, addr, src)
print("bucket is", bucket) # 786

ADDRMAN_TRIED_BUCKETS_PER_GROUP = 8
ADDRMAN_TRIED_BUCKET_COUNT = 256
def get_key(ip, port):
    ip_as_bytes = bytes(map(int, ip.split('.')))
    print(ip_as_bytes.hex())
    print((port // 0x100).to_bytes(1, 'little').hex())
    print((port & 0x0FF).to_bytes(1, 'little').hex())
    return ip_as_bytes + (port // 0x100).to_bytes(1, 'little') + (port & 0x0FF).to_bytes(1, 'little')

def get_tried_bucket(key, addr, port):
    addr_group = get_group_ipv4(addr)
    addr_id = get_key(addr, port) #00000000000000000000ffff fa010101208d
    print(addr_id.hex())
    hash1 = int.from_bytes(double_hash(key + bytes([len(addr_id)]) + addr_id), 'little')
    hash1 = hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP
    hash2 = int.from_bytes(double_hash(key + bytes([len(addr_group)]) + addr_group
                                           + hash1.to_bytes(8, 'little'))[:8], 'little')
    return hash2 % ADDRMAN_TRIED_BUCKET_COUNT

key = bytes.fromhex("1bd164d5d22d98dc2b5720c02ca95f732d0cb60cfcb495378d07cce5f258f741")
addr = "250.1.1.1"
port = 8333
src = "250.1.1.1"
bucket = get_tried_bucket(key, addr, port)
print("bucket is", bucket)
